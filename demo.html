<!doctype html>
<html lang="en">

	<head>
	<style>
		
	</style>
<meta name="description" content="Python slides">
		<meta name="author" content="Pierre Buesser">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<meta charset="utf-8">
		<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> -->
		
		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<!-- Themes : my custom tags  <red> <blue> etc -->
		<link rel="stylesheet" href="css/customTags.css">
		<!-- Themes : solarized1: my personnal version of solarized -->
		<link rel="stylesheet" href="css/theme/solarized1.css" id="theme">
		<!-- Themes : Black White League Sky Beige Simple Serif Blood Night Moon Solarized-->

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css"> 
		<!-- choice: monokai, zenburn, arduino-light, arta,ascetic, gruvbox-light,isbl-editor-light, xcode, vs //Atelier Cave Light, Atelier Dune Light-->
		<!--more at highlight.js -->


<!--   <script src="plugin/sculpt-master/js/sculpt.js" type="text/javascript"></script> -->
		
		<!-- <script src="js/skulpt.min.js" type="text/javascript"></script>-->

		<!-- Printing and PDF exports -->
		<script>
	
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );	
		</script>
	<!-- ************************skulpt************************************ -->
<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js" type="text/javascript"></script>  -->
<script src="http://www.skulpt.org/js/skulpt.min.js" type="text/javascript"></script> 
<script src="http://www.skulpt.org/js/skulpt-stdlib.js" type="text/javascript"></script> 
	<!-- ************************skulpt************************************ -->	  
	  
	</head>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
					<!-- ------------------------------------------------------------------------------------ -->
			<section>

			<h1>Suite du cours online</h1>
					<p>
						<small> P. Buesser et A. Villa</small>
					</p>
				</section>
		<!-- ------------------------------------------------------------------------------------ -->
			<section>

					<section id = "niveau0">
						<p>Les slides verticaux contiennent des commentaires et additions sur un même slide.
						 Vous pouvez y accédez avec les flèches de navigation</p>
						<br>
						<a href="#niveau1" >
							<img width="178" height="238" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section id = "niveau1">
						<h2>Niveau 1</h2>
						<p>Utiliser <em>la barre d'espace</em> pour naviguer à travers tout les slides.</p>
						<p>Pressez la touche  <em>ESC</em> pour avoir une vue générale des slides.</p>
						
					</section>
					<section>
						<h2>Niveau 3</h2>
						<ul>
						<li>Des données du web peuvent être intégrées, il est donc possible que certains slides apparaissent différemment sans connection.</li>
						<!-- <li>Après des changements (p. ex connection internet) vous pouvez rafraichir &#10227; la page pour voir les changements.</li> -->
						<li>Possible de copier-coller les sections de code sans problèmes de tabulations</li>
					</section>
					<section>
						<h2>Niveau 4</h2>
						<ul>
 						<li>Pour zoomer : maintenez <em>alt</em> (<em>ctrl</em> sous Linux)et cliquez sur un élément. Cliquez encore une fois pour revenir.</li>
						<li>Le texte contient des hyperliens vers des autres slides.</li>
						<li>Pour revenir après avoir cliqué sur un de ces liens, utilisez les flèches de navigation du browser (Firefox, etc).</li>
					</section>
					<section>
					</ul>
						<br>
						<a href="#niveau0"> Retour au slide principal.</a>
					</section>
					
				</section>
				<!-- ------------------------------------------------------------------------------------ -->
			<section>
				<section>
				<h3>3.16 – Destruction des instances </h3>
				<small>(slide 41 des anciennes slides)</small>
				<p>
				<cr>del</cr> <cg>monObjet</cg>
				</p>
				<p>
				La destruction d’une instance provoque 
				un appel au destructeur de la classe <cr>__del__(self)</cr>,
				la restitution de l’espace mémoire et la 
				suppression de la variable <cr>monObjet</cr>
				</p>
				</section>
				<section>
				<table>
  				<tr >
  					<td ><red><big2 >&#9888;</big2></red> </td>
    				<td >Le destructeur réalise le travail inverse du constructeur. 
						En général, Python se débrouille très bien tout seul pour effacer automatiquement 
						tout les objets inatteignables à l'aide du collecteur de déchets (garbage collector).</td>
  				</tr>
  				
  				</table>
				</section>
				
				
				</section>
				<!-- ------------------------------------------------------------------------------------ -->
				<section>
				<section id = "classFigure">
				<img src="images/umlFigure.png" alt="UML Figure" width="200"  align="right" class="my-right">
				<h3>3.16 – Destruction des instances: <a href = "#del"><mycode>del</mycode></a>	</h3>
<!-- 				les parametre de l'image se trouve dans les themes css -->


				<!--"9|9,10" pour eclairer par steps-->
				<pre ><code class="python" data-trim data-line-numbers="9,10" >
class Figure() :
	compteur = 0
	
	def __init__(self, largeur, hauteur) :
		self.nom = ''
		self.largeur = largeur
		self.hauteur = hauteur
		Figure.compteur += 1
	def __del__(self) :
		Figure.compteur -= 1

	@staticmethod
	def nombreinstances() :
		return Figure.compteur
				
					</code></pre>
					</section>
					<section id = "del">
  On a modifié la fonction <cr>__del__(self)</cr> par défaut de la classe <cg>Figure</cg> pour qu'elle diminue
  le compteur de 1 à chaque fois qu'on efface une instance. <br />
  Notez aussi <red>la méthode de classe</red> <cdb>nombreinstances()</cdb> 
  (-> elle peut être appelée à partir du nom de la classe : <cdb>nomClasse.fonction()</cdb>).
  
					</section>
					</section>
				<!-- ------------------------------------------------------------------------------------ -->
				<section>
				<section>				
				<h3>3.16 – Destruction des instances: del</h3>
				
				<pre><code class="python" data-trim data-line-numbers="1,2">
				rect = Rectangle(4, 5)
				del rect
				</code></pre>
				<p style="margin-bottom:10px"></p>
				<img src="images/memoireRect.png" alt="UML Figure" width="600"  align="center" >
				</section>				
				<section>
<cr>del</cr><cb> rect</cb> supprime la variable <cb>rect</cb> et l'objet en mémoire devient inatteignable.
				</section>
				
				</section>
<!-- ------------------------------------------------------------------------------------ -->
				<section>
				<section>
				<h3>3.16 – Destruction des instances: del</h3>
<pre><code class="python" data-trim data-line-numbers>
from figures import *               # importe figures.py
print Figure.nombreinstances()      # méthode de classe
#->0	
rect = Rectangle(4, 5)              # appel au constructeur
print rect.perimetre()
#->18.0
print Figure.nombreinstances()
#->1
cercle = Cercle(5)                  # appel au constructeur
cercle.perimetre()                  # polymorphisme :-)
#->31.4159265359
print Figure.nombreinstances()
#->2
del rect                            # appel au destructeur
print Figure.nombreinstances()
#->1
rect
#->NameError: name 'rect' is not defined
</code></pre>
				</section>
				<section>
On utilise la fonction <cdb>nombreinstances()</cdb>( définie <a href = "#classFigure">avant</a>) 
pour afficher le nombre d'instances de la classe figure. L'opérateur <cdb>del</cdb> (ligne 14) a appelé la fonction
<cdb>__del__(self)</cdb> qui a bien diminué le nombre d'instances. A la ligne 17
l'appel de la variable <cdb>rect</cdb> qui n'existe plus
génère une erreur.
				</section>
				</section>
<!-- ------------------------------------------------------------------------------------ -->				
				<section>
				<section>
				<h3>3.17 – Garbage collector : 
	     le ramasse-miette</h3>
<p class = taille75>
Python gère la mémoire avec un garbage collector qui
recycle automatiquement la mémoire qui n’est plus utilisée.
</p>
<p class = taille75>
Périodiquement, le garbage collector (gc)
vérifie le nombre de références pour chaque objet (variables, liste contenant l'objets etc.)
et recycle les objets inaccessibles (recycle la mémoire de l'objet).
</p>
<p class = taille75>
Utilisation explicite par le programmeur :
</p>
<pre><code class="python" data-trim data-line-numbers>
>>>	import gc
>>>	gc.collect()# retourne nbr objets inaccessibles et les efface
12
>>> gc.collect()
0
</code></pre>
				</section>
				<section>
				Le <cdb>gc</cdb> évite de surcharger la mémoire
				avec des objets qui deviennent inatteignables lors du déroulement du code.<br />
				</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->				
<section>
				<section>
				<h3>3.17 – Garbage collector : Exemple</h3>
				<p>
				Considérons la structure en arbre suivante
				 (qui n’est pas une structure de classes), on veut la représenter à l’aide d’instances d’une seule classe:
				 </p>
			<img src="images/arbre.png" alt="UML Figure" width="600"  align="center">
				</section>
				<section>
				<p>
				L'arbre représente une hiérarchie de direction ou des secteurs dans une entreprise,
				chaque noeud possède un noeud parent et plusieurs noeuds enfants. On va donc créer une classe 
				avec ces deux attributs : un noeud parent <cdb>self.sup</cdb> et une liste 
				de noeuds enfant <cdb>self.inf</cdb>.
				</p>
				<p>
				 Chaque noeud de l'arbre sera une instance de cette classe.
				 </p>
				</section>
				
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>

	<section>
		<h3>3.17 – Garbage collector : Exemple</h3>
		<p class = taille75>La classe <cr>Niv</cr> représente un noeud de l'arbre :</p>
		<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
class Niv():
	compteur = 0
	def __init__(self, nom):
		self.nom = nom
		self.sup = None #par défaut pas de supérieur
		self.inf = []   #par défaut liste vide de subalternes
		Niv.compteur += 1

	@staticmethod
	def nombreinstances() : return Niv.compteur

	def addNiv(self, niveau):
	niveau.sup = self
	self.inf.append(niveau)

	def organigramme(self):
		for f in self.inf:
			print self.nom, "dirige ", f.nom
			f.organigramme()
</code></pre>
	</section>
	<section>
	<ul>
 	<li>L'attribut <cdb>nom</cdb> contient le nom du noeud (p. ex "dir").</li>
	<li>On déclare une méthode de classe pour compter les instances (avec <mycode style="color:lightblue;">@staticmethod</mycode>) 
	comme dans la classe Figure.</li>
	<li>Ligne 12: la fonction <ctomato> addNiv</ctomato> permet d'ajouter un élément dans la liste des enfants.
	Le parent de ce noeud  enfant est donc le noeud  qui rajoute cet enfant, représenté 
	par la variable <cdb>self</cdb> (ligne 13)</li>
		</ul>
	</section>
	<section>
	<ul>
	<li>Ligne 16 : la méthode <ctomato>organigramme</ctomato> permet d'afficher l'arbre par récurrence
	selon l'algorithme ci-dessous : </li>
	</ul><!-- data-line-numbers -->
	<pre><code class="python" data-trim  style="font-size:25px;"> 
def organigramme(self):
	parcours tout les enfant du noeud self:
		imprime chaque enfant
		pour chaque enfant rapelle organigramme()
</code></pre>
<ul>
	<li> L'appel récursif permet d'afficher le sous arbre à partir d'un enfant.</li>
	</ul>
	</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<img src="images/arbre.png" alt="UML Figure" width="400"  align="right" class="my-right">
<h3>3.17 – Garbage collector : Exemple</h3>
<p class = taille75 align = left>On peut maintenant créer les instances correspondant au schéma de l'arbre :  </p>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
>>> pdg = Niv("dir")
>>> pdg.organigramme()
>>> pdg.addNiv(Niv("export"))
>>> pdg.addNiv(Niv("natl"))
>>> pdg.addNiv(Niv("assist"))
>>> print pdg.inf
[<__main__.Niv instance at 0x10a454ea8>, <__main__.Niv instance at 0x10a45a440>,
<__main__.Niv instance at 0x10a45a7a0>]
>>> pdg.organigramme()
dir dirige  export
dir dirige  natl
dir dirige  assist
</code></pre>
<p class = taille75 align  =left> suite du code slide ci-dessous...</p>
</section>
<section>
<p class = taille75 align = left> ...suite</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
>>> pdg.inf[0].addNiv(Niv("Am"))
>>> pdg.inf[0].addNiv(Niv("Asia"))
>>> pdg.inf[0].addNiv(Niv("Eu"))
>>> pdg.inf[0].addNiv(Niv("RoW"))
>>> pdg.inf[2].addNiv(Niv("CustSat"))
>>> pdg.inf[2].addNiv(Niv("Repair"))
>>> pdg.inf[2].inf[1].addNiv(Niv("site"))
>>> pdg.inf[2].inf[1].addNiv(Niv("remote"))
>>> pdg.organigramme()
dir dirige  export
export dirige  Am
export dirige  Asia
export dirige  Eu
export dirige  RoW
dir dirige  natl
dir dirige  assist
assist dirige  CustSat
assist dirige  Repair
Repair dirige  site
Repair dirige  remote
</code></pre>
</section>

<section>
<p align = left>Explications : </p>
<ul>
<li>On créait le noeud racine de l'arbre <ctomato>pdg = Niv("dir")</ctomato></li>
<li>On rajoute les noeuds enfants de pdg avec des commandes du type : <ctomato>pdg.addNiv(Niv("export"))</ctomato></li>
<li>Pour chacun de ces enfants on rajoute leurs enfants. Par exemple <ctomato>pdg.inf[0].addNiv(Niv("Am"))</ctomato>
ajoute le noeud <ctomato>"Am"</ctomato> à <ctomato>pdg.inf[0]</ctomato>  (le premier enfant de <ctomato>pdg</ctomato>).</li>
<li>On continue jusqu'à avoir créé tout l'arbre...</li>
</ul>
</section>
<section>
<ul>
<li>Remarque : cette manière de construire l'arbre n'est pas très pratique,
 il serait plus facile de lire un fichier qui contient les informations de l'arbre de manière structurées</li>
</ul>
</section>

<section>
	<ul>
	<li>Exercice : créez votre propre méthode d'affichage de l'arbre, ajoutez-la au code et testez-la.
	 Utilisez le code des slides ou le code en lien ci-dessous. 
	</li>
	<!-- 
<li>Exemple de code d'affichage : </li>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
def organigramme2(self, depth = 0):
	if(depth==0):
		print "0 "+ self.nom
		for f in self.inf:
			print (depth+1)*"   " + str(depth+1)+" "+ f.nom
			f.organigramme2(depth+1)
</code></pre>
 -->
	<li><a href = "codesPython/Niv.py">Lien vers le code complet Niv.py</a> qui 
	se trouve dans le dossier "codesPython/" des slides. </li>
	</ul>
	</section>

</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<img src="images/arbre.png" alt="UML Figure" width="300"  align="right" class="my-right" >
<h3>3.17 – Garbage collector : Exemple</h3>
<p class = taille75 align  =left> On va tester le "garbage collector"</p>
<p style = "margin-bottom:50px;"></p>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
>>> import gc
>>> pdg.nombreinstances()
12
>>> 
>>> pdg.inf[1].nom
'natl'
>>> del pdg.inf[1]
>>> print gc.collect(), "objets inatteignables"
0 objets inatteignables
>>> # parce que 'natl' n'avait pas de subalternes
>>> pdg.inf[1].nom
"assist"
>>> del pdg.inf[1]
#gc.collect efface les objets inatteignables et renvoie leur nombre
>>> print gc.collect(), "objets inatteignables"
15 objets inatteignables
# parce que 'assist' a été effacé avec la liste des subalternes par
#l'appel de gc.collect()
>>> print gc.collect(), "objets inatteignables"
0 objets inatteignables
</code></pre>
</section>
<section>
<ul>
	<li>Ligne 1 : On importe le module gc</li>
	<li>Ligne 7 : On efface le deuxième enfant de "pdg", comme il ne possède pas d'enfant,
	 aucun noeud ne sera rendu inatteignable</li>
	<li>Ligne 8 : la commande <ctomato>gc.collect()</ctomato> force le recyclage de la mémoire
	et renvoie le nombre d'objets qui étaient inatteignables. Il y en a 0.</li>
	<li>Ligne 13 : Par contre si on efface un noeud qui possède des sous-noeuds <ctomato>pdg.inf[1]</ctomato>,
	 ces derniers ne seront plus atteignables. </li>
	
</ul>	
</section>
<section>
<ul>
	<li>Ligne 15-16 : L'appel <ctomato>print gc.collect()</ctomato> va bien afficher
	 un certain nombre d'objets inatteignables :  15.</li>
	 <li>Les 15 objets inatteignables sont comptabilisés de manière compliquée 
	 (en prenant en compte les attributs).</li>
	 <li> Un deuxième appel à <ctomato>gc.collect()</ctomato> affiche bien zéro puisque l'appel précédent a forcé
	 le "nettoyage" de la mémoire.
	 </li>
</ul>
</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<h3>3.18 – Comparaison d'objets</h3>
<p>Les comparaisons entre objets peuvent s'avérer compliquées, par défaut python compare les adresses mémoire.</p>
<p align = left>Lorsqu'on déclare un objet: 	<cdb>objet = Classe(...)</cdb><br />
Python crée une référence vers l'objet créé</p>
<img src="images/memoireCopy.png" alt="UML Figure" width="600"  align="center">
</section>
<!-- ------------------------------------------------------------------------------------ -->

<section>
<h3>3.18 – Comparaison d'objets</h3>
<p class = taille75>Deux objets  <cg>obj1</cg>  et  <cg>obj2</cg> sont égaux, i.e. 
<cg>obj1</cg> <cr>==</cr> <cg>obj2</cg> est vrai si:</p>
<img src="images/objetEgaux.png" alt="UML Figure" width="500"  align="center">
<p class = taille75>si  les variables <cg>obj1</cg>  et  <cg>obj2</cg> contiennent la même référence,
 et donc sont liés au même endroit en mémoire qui contient les
 attributs de l'objet (il n'y a donc qu'un seul objet).</p>
 <p class = taille75>Problème : comment déterminer
  si le contenu de  <cg>obj1</cg> est le même que le contenu de  <cg>obj2</cg>, si ces deux objets sont différents ?</p>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<h3>3.18 – Comparaison d'objets</h3>
<p>La notion d’égalité est différente de la notion d’identité
</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:25px;">
>>> figA = figB = Figure(3, 4)
>>> figC = Figure(3, 4)
>>>	
>>> figA == figB    # sont bien identiques (références)
True
>>>	
>>> figA == figC    # sont bien égaux (valeurs)
False               # mais euh ?!
>>>	
</pre></code>
</section>
<section>
<ul>
	<li>Ligne 7 : La comparaison de deux objets différents renvoie la valeur <cdb>False</cdb> 
	car cela compare les deux adresses mémoire qui sont différentes.</li>
	<li><cg>figA</cg> et <cg>figC</cg> on les deux été construit à l'aide du constructeur
	 <cg>Figure()</cg> et donc pour chacun un objet a été créé en mémoire. Alors que <cg>figB</cg> 
	 est juste une copie de l'adresse de <cg>figA</cg>. </li>
</ul>	
</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<h3>3.18 – Comparaison d'objets</h3>
<p class = taille75>Représentation de la mémoire après le code ci-dessous:</p>

<pre><code class="python" data-trim data-line-numbers style="font-size:25px;">
>>> figA = figB = Figure(3, 4)
>>> figC = Figure(3, 4)
</pre></code>
<p style="margin-bottom:10px"></p>
<img src="images/memoireFigA.png" alt="UML Figure" width="700"  align="center">
</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>

<h3>3.18 – Comparaison d'objets<img src="images/umlFigure2.png" alt="UML Figure" width="180"  align="right" class="my-right"></h3>
<p class = taille75>A priori ce résultat est embêtant ! La solution est de créer une méthode 
 <cg> egal() </cg> dans la classe <cg>Figure</cg>:</p>
 <pre><code class="python" data-trim data-line-numbers style="font-size:25px;">
class Figure():
	def egal(self, autre):
		if isinstance(autre, Figure) :
			return self.nom==autre.nom \
			and self.largeur==autre.largeur \ 
			and self.hauteur==autre.hauteur
		else:
			return False
figA = figB = Figure(3, 4)
figC = Figure(3, 4)
figA == figC#-> False
figA.egal(figC) #->True
</pre></code>
</section>
<section>
<ul>
	<li>La fonction <ctomato>egal()</ctomato> compare tout les attributs des deux objets et 
	renvoie <cg>True</cg> si ils sont tous égaux.</li>
</ul>
</section>
</section>

<!-- ------------------------------------------------------------------------------------ -->
<section>
<h3>3.18 – Comparaison d'objets</h3>
<p>Python permet la redéfinition  des opérations de comparaison entre objets dans chaque classe.</p>
<table style= "font-size: 75%">
  				<tr ><th >Opérateur </th><th >Méthode correspondante</th></tr>
  				
					<tr ><td> < </th><td >__lt__(self, other)</th></tr>
					<tr ><td> <= </th><td >__le__(self, other)</th></tr>
					<tr ><td> == </th><td >__eq__(self, other)</th></tr>
					<tr ><td> != </th><td >__ne__(self, other)</th></tr>
					<tr ><td> >= </th><td >__ge__(self, other)</th></tr>
					<tr ><td> > </th><td >__gt__(self, other)</th></tr>
</table>					
  				    				  
</section>
<!-- ------------------------------------------------------------------------------------ -->

<section>
<h3>3.18 – Comparaison d'objets</h3>
<p class = taille75>On peut <blue>surcharger</blue> la méthode d'implémentation standard de l'égalité
   <cg>__eq__()</cg> dans la classe  <cg>Figure</cg>. On remplace <cg>egal</cg> par <cg>__eq__</cg>: </p>
   <pre><code class="python" data-trim data-line-numbers style="font-size:20px;">
class Figure():
	...
	def __eq__(self, autre):
		if isinstance(autre, Figure) :
			return self.nom==autre.nom)\
			and self.largeur==autre.largeur)\ 
			and self.hauteur==autre.hauteur
		else:
			return False
figA = figB = Figure(3, 4)
figC = Figure(3, 4)
figA == figC  #-> True (car 	appel à la fonction __eq__)
</pre></code>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<h3>3.19 – Représentation textuelle</h3>
<p class = taille50>Imprimer un objet avec <ctomato>print</ctomato> renvoie son adresse mémoire :</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:20px;">
figA = Rectangle(3,4)
print figA
#-> <__main__.Rectangle instance at 0x102b9d908>
</pre></code>
<p class = taille50>On peut également surcharger la méthode d'implémentation standard <ctomato>__str__()</ctomato>
dans la classe  <cg>Figure</cg>. Celle ci est appelée dans les fonctions <ctomato>str()</ctomato>,
<ctomato>print()</ctomato> (et <ctomato>format()</ctomato>).</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:20px;">
class Figure():
	...
	def __str__(self):
		return self.nom + " de " + \
		str(self.largeur) + " x " + str(self.hauteur)
figA = Rectangle(3,4)
str(figA)#-> 'Rectangle de 3 x 4'
print figA # print fait appel a str()
#->Rectangle de 3 x 4
</pre></code>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<!-- 
<figure ><img src="images/symboleFichier.png" alt="UML Figure" width="100" alt = "fraction.py" align="right" class = "my-right">
<figcaption><small>fraction.py</small></figcaption></figure>
 -->
<h3>3.20 – Exemple: module fraction.py</h3>
<p class = taille75>On va écrire un module appelé  <cg>fraction.py</cg>  qui permet d'effectuer des opérations élémentaires 
( +,  - ,  * , / ) sur des fractions positives.</p> <p class = taille50>A noter qu'il est trivial de considérer 
également le cas des fractions négatives, mais cela complique le code et n'amène rien de plus.</p>

<pre><code class="python" data-trim data-line-numbers style="font-size:20px;">
# -*- coding: utf-8 -*-
class Fraction():
	# constructeur et attributs
	def __init__(self, num = 0, den = 1):
		self.num = num
		if (den == 0): 
			erreur("Dénominateur nul") #fonction d'erreur
			self.den = den
	def __str__(self):
		return str(self.num) + "/" + str(self.den)
</pre></code>
</section>
<section>
<ul>
	<li>
	On créer une classe <ctomato>Fraction</ctomato> avec deux attrbuts: le numérateur
	 et le dénominateur de la fraction : <cdb>num</cdb> et <cdb>den</cdb>.
	<li>Si le dénominateur est nul, on appelle une fonction <cdb>erreur</cdb> pour afficher l'erreur. Cette fonction sera définie plus tard</li>
	</li>
	<li>On créait une fonction <ctomato>__str__</ctomato> pour afficher l'objet plus facilement.</li>	
	
</ul>
</section>

</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>

</section>
<!-- ------------------------------------------------------------------------------------ -->
				
				
				


			</div>

		</div>

		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		Reveal.configure({ slideNumber: true });  
		Reveal.configure({ slideNumber: 'h/v' });
		</script>
	</body>
</html>
