<!doctype html>



<html>
	<head>
		<!-- pBuess My personnal tags:--><!-- font-family: "Lato", sans-serif; font-size: 40px; font-weight: normal; color: #657b83 -->
	<style>
		
	</style>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		
		<title>reveal.js</title>
<link rel="stylesheet" href="css/customTags.css">
		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<!-- Themes : my custom tags  <red> <blue> etc -->
		
		<!-- Themes : solarized 1: my personnal version of solarized -->
		<link rel="stylesheet" href="css/theme/Solarized1.css" id="theme">
		<!-- Themes : Black White League Sky Beige Simple Serif Blood Night Moon Solarized-->

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css"> 
		<!-- choice: monokai, zenburn, arduino-light, arta,ascetic, gruvbox-light,isbl-editor-light, xcode, vs //Atelier Cave Light, Atelier Dune Light-->
		<!--more at highlight.js -->


<!--   <script src="plugin/sculpt-master/js/sculpt.js" type="text/javascript"></script> -->
		
		<!-- <script src="js/skulpt.min.js" type="text/javascript"></script>-->

		<!-- Printing and PDF exports -->
		<script>
	
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );	
		</script>
	<!-- ************************skulpt************************************ -->
<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js" type="text/javascript"></script>  -->
<script src="http://www.skulpt.org/js/skulpt.min.js" type="text/javascript"></script> 
<script src="http://www.skulpt.org/js/skulpt-stdlib.js" type="text/javascript"></script> 
	<!-- ************************skulpt************************************ -->	  
	  
	</head>
	<body>
	
	
	<!-- ************************skulpt************************************ -->
	
<!-- 
	<script type="text/javascript"> 
// output functions are configurable.  This one just appends some text
// to a pre element.
function outf(text) { 
    var mypre = document.getElementById("output"); 
    mypre.innerHTML = mypre.innerHTML + text; 
} 
function builtinRead(x) {
    if (Sk.builtinFiles === undefined || Sk.builtinFiles["files"][x] === undefined)
            throw "File not found: '" + x + "'";
    return Sk.builtinFiles["files"][x];
}

// Here's everything you need to run a python program in skulpt
// grab the code from your textarea
// get a reference to your pre element for output
// configure the output function
// call Sk.importMainWithBody()

function runit() { 
   var prog = document.getElementById("yourcode").value; 
   var mypre = document.getElementById("output"); 
   mypre.innerHTML = ''; 
   Sk.pre = "output";
   Sk.configure({output:outf, read:builtinRead}); 
   (Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = 'mycanvas';
   var myPromise = Sk.misceval.asyncToPromise(function() {
       return Sk.importMainWithBody("<stdin>", false, prog, true);
   });
   myPromise.then(function(mod) {
       console.log('success');
   },
       function(err) {
       console.log(err.toString());
   });
}


function outf2(text) { 
    var mypre = document.getElementById("output2"); 
    mypre.innerHTML = mypre.innerHTML + text; 
} 
function runit2() { 
   var prog = document.getElementById("yourcode2").value; 
   var mypre = document.getElementById("output2"); 
   mypre.innerHTML = ''; 
   Sk.pre = "output2";
   Sk.configure({output:outf2, read:builtinRead}); 
   // (Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = 'mycanvas';
   var myPromise = Sk.misceval.asyncToPromise(function() {
       return Sk.importMainWithBody("<stdin>", false, prog, true);
   });
   myPromise.then(function(mod) {
       console.log('success');
   },
       function(err) {
       console.log(err.toString());
   });
}

</script> 
 -->
	
	<!-- ************************skulpt************************************ -->
	
	
	
	
	
		<div class="reveal">
			<div class="slides">
			
<!-- ************************skulpt slide************************************ -->			
<!-- 
		<section>
		<form>
<textarea id="yourcode2" cols="40" rows="4" style="font-size:0.8em">
print 2*3
</textarea>
<br/>
<button type = "button" onclick="runit2()" >Run</button>
<!~~ <button onclick="clear_output();" class="btn btn-danger large">Clear</button> ~~>
</form> 
<pre id="output2" style="height:200px; scroll: true">
</pre>
</section>

<section>			
<h4>Try This</h4> 
<form> 
<textarea id="yourcode" cols="40" rows="5">
import turtle
t = turtle.Turtle()
t.forward(100)
print "Hello World" 
</textarea><br /> 
<button type="button" onclick="runit()">Run</button> 
</form> 
<pre id="output" ></pre> 
<!~~ If you want turtle graphics include a canvas ~~>
<div id="mycanvas"></div> 
</section>	
 -->
<!-- ************************skulpt slide************************************ -->				
		<!-- ------------------------------------------------------------------------------------ -->
			<section>

			<h1>Suite du cours online</h1>
					<p>
						<small> P. Buesser et A. Villa</small>
					</p>
				</section>
		<!-- ------------------------------------------------------------------------------------ -->
			<section>

					<section id = "niveau0">
						<p>Les slides verticaux contiennent des commentaires et additions sur un même slide.
						 Vous pouvez y accédez avec les flèches de navigation</p>
						<br>
						<a href="#niveau1" >
							<img width="178" height="238" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section id = "niveau1">
						<h2>Niveau 1</h2>
						<p>Utiliser <em>la barre d'espace</em> pour naviguer à travers tout les slides.</p>
						<p>Pressez la touche  <em>ESC</em> pour avoir une vue générale des slides.</p>
						
					</section>
					<section>
						<h2>Niveau 3</h2>
						<ul>
						<li>Des données du web peuvent être intégrées, il est donc possible que certains slides apparaissent différemment sans connection.</li>
						<!-- <li>Après des changements (p. ex connection internet) vous pouvez rafraichir &#10227; la page pour voir les changements.</li> -->
						<li>Possible de copier-coller les sections de code sans problèmes de tabulations</li>
					</section>
					<section>
						<h2>Niveau 4</h2>
						<ul>
 						<li>Pour zoomer : maintenez <em>alt</em> (<em>ctrl</em> sous Linux)et cliquez sur un élément. Cliquez encore une fois pour revenir.</li>
						<li>Le texte contient des hyperliens vers des autres slides.</li>
						<li>Pour revenir après avoir cliqué sur un de ces liens, utilisez les flèches de navigation du browser (Firefox, etc).</li>
					</section>
					<section>
					</ul>
						<br>
						<a href="#niveau0"> Retour au slide principal.</a>
					</section>
					
				</section>
				<!-- ------------------------------------------------------------------------------------ -->
			<section>
				<section>
				<h3>3.16 – Destruction des instances </h3>
				<small>(slide 41 des anciennes slides)</small>
				<p>
				<cr>del</cr> <cg>monObjet</cg>
				</p>
				<p>
				La destruction d’une instance provoque 
				un appel au destructeur de la classe <cr>__del__(self)</cr>,
				la restitution de l’espace mémoire et la 
				suppression de la variable <cr>monObjet</cr>
				</p>
				</section>
				<section>
				<table>
  				<tr >
  					<td ><red><big2 >&#9888;</big2></red> </td>
    				<td >Le destructeur réalise le travail inverse du constructeur. 
						En général, Python se débrouille très bien tout seul pour effacer automatiquement 
						tout les objets inatteignables à l'aide du collecteur de déchets (garbage collector).</td>
  				</tr>
  				
  				</table>
				</section>
				
				
				</section>
				<!-- ------------------------------------------------------------------------------------ -->
				<section>
				<section id = "classFigure">
				<h3>3.16 – Destruction des instances: <a href = "#del"><mycode>del</mycode></a>	
<!-- 				les parametre de l'image se trouve dans les themes css -->
				<img src="images/umlFigure.png" alt="UML Figure" width="200"  align="right" class="my-right"></h3>

				<!--"9|9,10" pour eclairer par steps-->
				<pre ><code class="python" data-trim data-line-numbers="9,10" >
class Figure() :
	compteur = 0
	
	def __init__(self, largeur, hauteur) :
		self.nom = ''
		self.largeur = largeur
		self.hauteur = hauteur
		Figure.compteur += 1
	def __del__(self) :
		Figure.compteur -= 1

	@staticmethod
	def nombreinstances() :
		return Figure.compteur
				
					</code></pre>
					</section>
					<section id = "del">
  On a modifié la fonction <cr>__del__(self)</cr> par défaut de la classe <cg>Figure</cg> pour qu'elle diminue
  le compteur de 1 à chaque fois qu'on efface une instance. <br />
  Notez aussi <red>la méthode de classe</red> <cdb>nombreinstances()</cdb> 
  (-> elle peut être appelée à partir du nom de la classe : <cdb>nomClasse.fonction()</cdb>).
  
					</section>
					</section>
				<!-- ------------------------------------------------------------------------------------ -->
				<section>
				<section>				
				<h3>3.16 – Destruction des instances: del</h3>
				
				<pre><code class="python" data-trim data-line-numbers="1,2">
				rect = Rectangle(4, 5)
				del rect
				</code></pre>
				<img src="images/memoireRect.png" alt="UML Figure" width="600"  align="center" >
				</section>				
				<section>
<cr>del</cr><cb> rect</cb> supprime la variable <cb>rect</cb> et l'objet en mémoire devient inatteignable.
				</section>
				
				</section>
<!-- ------------------------------------------------------------------------------------ -->
				<section>
				<section>
				<h3>3.16 – Destruction des instances: del</h3>
<pre><code class="python" data-trim data-line-numbers>
from figures import *               # importe figures.py
print Figure.nombreinstances()      # méthode de classe
#->0	
rect = Rectangle(4, 5)              # appel au constructeur
print rect.perimetre()
#->18.0
print Figure.nombreinstances()
#->1
cercle = Cercle(5)                  # appel au constructeur
cercle.perimetre()                  # polymorphisme :-)
#->31.4159265359
print Figure.nombreinstances()
#->2
del rect                            # appel au destructeur
print Figure.nombreinstances()
#->1
rect
#->NameError: name 'rect' is not defined
</code></pre>
				</section>
				<section>
On utilise la fonction <cdb>nombreinstances()</cdb>( définie <a href = "#classFigure">avant</a>) 
pour afficher le nombre d'instances de la classe figure. L'opérateur <cdb>del</cdb> (ligne 14) a appelé la fonction
<cdb>__del__(self)</cdb> qui a bien diminué le nombre d'instances. A la ligne 17
l'appel de la variable <cdb>rect</cdb> qui n'existe plus
génère une erreur.
				</section>
				</section>
<!-- ------------------------------------------------------------------------------------ -->				
				<section>
				<section>
				<h3>3.17 – Garbage collector : 
	     le ramasse-miette</h3>
<p class = taille75>
Python gère la mémoire avec un garbage collector qui
recycle automatiquement la mémoire qui n’est plus utilisée.
</p>
<p class = taille75>
Périodiquement, le garbage collector (gc)
vérifie le nombre de références pour chaque objet (variables, liste contenant l'objets etc.)
et recycle les objets inaccessibles (recycle la mémoire de l'objet).
</p>
<p class = taille75>
Utilisation explicite par le programmeur :
</p>
<pre><code class="python" data-trim data-line-numbers>
>>>	import gc
>>>	gc.collect()# retourne nbr objets inaccessibles et les efface
12
>>> gc.collect()
0
</code></pre>
				</section>
				<section>
				Le <cdb>gc</cdb> évite de surcharger la mémoire
				avec des objets qui deviennent inatteignables lors du déroulement du code.<br />
				</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->				
<section>
				<section>
				<h3>3.17 – Garbage collector : Exemple</h3>
				<p>
				Considérons la structure en arbre suivante
				 (qui n’est pas une structure de classes), on veut la représenter à l’aide d’instances d’une seule classe:
				 </p>
			<img src="images/arbre.png" alt="UML Figure" width="600"  align="center">
				</section>
				<section>
				<p>
				L'arbre représente une hiérarchie de direction ou des secteurs dans une entreprise,
				chaque noeud possède un noeud parent et plusieurs noeuds enfants. On va donc créer une classe 
				avec ces deux attributs : un noeud parent <cdb>self.sup</cdb> et une liste 
				de noeuds enfant <cdb>self.inf</cdb>.
				</p>
				<p>
				 Chaque noeud de l'arbre sera une instance de cette classe.
				 </p>
				</section>
				
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>

	<section>
		<h3>3.17 – Garbage collector : Exemple</h3>
		<p class = taille75>La classe <cr>Niv</cr> représente un noeud de l'arbre :</p>
		<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
class Niv():
	compteur = 0
	def __init__(self, nom):
		self.nom = nom
		self.sup = None #par défaut pas de supérieur
		self.inf = []   #par défaut liste vide de subalternes
		Niv.compteur += 1

	@staticmethod
	def nombreinstances() : return Niv.compteur

	def addNiv(self, niveau):
	niveau.sup = self
	self.inf.append(niveau)

	def organigramme(self):
		for f in self.inf:
			print self.nom, "dirige ", f.nom
			f.organigramme()
</code></pre>
	</section>
	<section>
	<ul>
 	<li>L'attribut <cdb>nom</cdb> contient le nom du noeud (p. ex "dir").</li>
	<li>On déclare une méthode de classe pour compter les instances (avec <mycode style="color:lightblue;">@staticmethod</mycode>) 
	comme dans la classe Figure.</li>
	<li>Ligne 12: la fonction <ctomato> addNiv</ctomato> permet d'ajouter un élément dans la liste des enfants.
	Le parent de ce noeud  enfant est donc le noeud  qui rajoute cet enfant, représenté 
	par la variable <cdb>self</cdb> (ligne 13)</li>
		</ul>
	</section>
	<section>
	<ul>
	<li>Ligne 16 : la méthode <ctomato>organigramme</ctomato> permet d'afficher l'arbre par récurrence
	selon l'algorithme ci-dessous : </li>
	</ul><!-- data-line-numbers -->
	<pre><code class="python" data-trim  style="font-size:25px;"> 
def organigramme(self):
	parcours tout les enfant du noeud self:
		imprime chaque enfant
		pour chaque enfant rapelle organigramme()
</code></pre>
<ul>
	<li> L'appel récursif permet d'afficher le sous arbre à partir d'un enfant.</li>
	</ul>
	</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<img src="images/arbre.png" alt="UML Figure" width="400"  align="right" class="my-right">
<h3>3.17 – Garbage collector : Exemple</h3>
<p class = taille75>On peut maintenant créer les instances correspondant au schéma de l'arbre :  </p>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
>>> pdg = Niv("dir")
>>> pdg.organigramme()
>>> pdg.addNiv(Niv("export"))
>>> pdg.addNiv(Niv("natl"))
>>> pdg.addNiv(Niv("assist"))
>>> print pdg.inf
[<__main__.Niv instance at 0x10a454ea8>, <__main__.Niv instance at 0x10a45a440>,
<__main__.Niv instance at 0x10a45a7a0>]
>>> pdg.organigramme()
dir dirige  export
dir dirige  natl
dir dirige  assist
</code></pre>
<p class = taille75 align  =left> suite du code slide ci-dessous...</p>
</section>
<section>
<p class = taille75 align = left> ...suite</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
>>> pdg.inf[0].addNiv(Niv("Am"))
>>> pdg.inf[0].addNiv(Niv("Asia"))
>>> pdg.inf[0].addNiv(Niv("Eu"))
>>> pdg.inf[0].addNiv(Niv("RoW"))
>>> pdg.inf[2].addNiv(Niv("CustSat"))
>>> pdg.inf[2].addNiv(Niv("Repair"))
>>> pdg.inf[2].inf[1].addNiv(Niv("site"))
>>> pdg.inf[2].inf[1].addNiv(Niv("remote"))
>>> pdg.organigramme()
dir dirige  export
export dirige  Am
export dirige  Asia
export dirige  Eu
export dirige  RoW
dir dirige  natl
dir dirige  assist
assist dirige  CustSat
assist dirige  Repair
Repair dirige  site
Repair dirige  remote
</code></pre>
</section>

<section>
<p align = left>Explications : </p>
<ul>
<li>On créait le noeud racine de l'arbre <ctomato>pdg = Niv("dir")</ctomato></li>
<li>On rajoute les noeuds enfants de pdg avec des commandes du type : <ctomato>pdg.addNiv(Niv("export"))</ctomato></li>
<li>Pour chacun de ces enfants on rajoute leurs enfants. Par exemple <ctomato>pdg.inf[0].addNiv(Niv("Am"))</ctomato>
ajoute le noeud <ctomato>"Am"</ctomato> à <ctomato>pdg.inf[0]</ctomato>  (le premier enfant de <ctomato>pdg</ctomato>).</li>
<li>On continue jusqu'à avoir créé tout l'arbre...</li>
</ul>
</section>
<section>
<ul>
<li>Remarque : cette manière de construire l'arbre n'est pas très pratique,
 il serait plus facile de lire un fichier qui contient les informations de l'arbre de manière structurées</li>
</ul>
</section>

<section>
	<ul>
	<li>Exercice : créez votre propre méthode d'affichage de l'arbre, ajoutez-la au code et testez-la.
	 Utilisez le code des slides ou le code en lien ci-dessous. 
	</li>
	<!-- 
<li>Exemple de code d'affichage : </li>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
def organigramme2(self, depth = 0):
	if(depth==0):
		print "0 "+ self.nom
		for f in self.inf:
			print (depth+1)*"   " + str(depth+1)+" "+ f.nom
			f.organigramme2(depth+1)
</code></pre>
 -->
	<li><a href = "codesPython/Niv.py">Lien vers le code complet Niv.py</a> qui 
	se trouve dans le dossier "codesPython/" des slides. </li>
	</ul>
	</section>

</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<img src="images/arbre.png" alt="UML Figure" width="300"  align="right" class="my-right">
<h3>3.17 – Garbage collector : Exemple</h3>
<p class = taille75 align  =left> On va tester le "garbage collector"</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:18px;">
>>> import gc
>>> pdg.nombreinstances()
12
>>> 
>>> pdg.inf[1].nom
'natl'
>>> del pdg.inf[1]
>>> print gc.collect(), "objets inatteignables"
0 objets inatteignables
>>> # parce que 'natl' n'avait pas de subalternes
>>> pdg.inf[1].nom
"assist"
>>> del pdg.inf[1]
#gc.collect efface les objets inatteignables et renvoie leur nombre
>>> print gc.collect(), "objets inatteignables"
15 objets inatteignables
# parce que 'assist' a été effacé avec la liste des subalternes par
#l'appel de gc.collect()
>>> print gc.collect(), "objets inatteignables"
0 objets inatteignables
</code></pre>
</section>
<section>
<ul>
	<li>Ligne 1 : On importe le module gc</li>
	<li>Ligne 7 : On efface le deuxième enfant de "pdg", comme il ne possède pas d'enfant,
	 aucun noeud ne sera rendu inatteignable</li>
	<li>Ligne 8 : la commande <ctomato>gc.collect()</ctomato> force le recyclage de la mémoire
	et renvoie le nombre d'objets qui étaient inatteignables. Il y en a 0.</li>
	<li>Ligne 13 : Par contre si on efface un noeud qui possède des sous-noeuds <ctomato>pdg.inf[1]</ctomato>,
	 ces derniers ne seront plus atteignables. </li>
	
</ul>	
</section>
<section>
<ul>
	<li>Ligne 15-16 : L'appel <ctomato>print gc.collect()</ctomato> va bien afficher
	 un certain nombre d'objets inatteignables :  15.</li>
	 <li>Les 15 objets inatteignables sont comptabilisés de manière compliquée 
	 (en prenant en compte les attributs).</li>
	 <li> Un deuxième appel à <ctomato>gc.collect()</ctomato> affiche bien zéro puisque l'appel précédent a forcé
	 le "nettoyage" de la mémoire.
	 </li>
</ul>
</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<h3>3.18 – Comparaison d'objets</h3>
<p>Les comparaisons entre objets peuvent s'avérer compliquées, par défaut python compare les adresses mémoire.</p>
<p align = left>Lorsqu'on déclare un objet: 	<cdb>objet = Classe(...)</cdb><br />
Python crée une référence vers l'objet créé</p>
<img src="images/memoireCopy.png" alt="UML Figure" width="600"  align="center">
</section>
<!-- ------------------------------------------------------------------------------------ -->

<section>
<h3>3.18 – Comparaison d'objets</h3>
<p class = taille75>Deux objets  <cg>obj1</cg>  et  <cg>obj2</cg> sont égaux, i.e. 
<cg>obj1</cg> <cr>==</cr> <cg>obj2</cg> est vrai si:</p>
<img src="images/objetEgaux.png" alt="UML Figure" width="500"  align="center">
<p class = taille75>si  les variables <cg>obj1</cg>  et  <cg>obj2</cg> contiennent la même référence,
 et donc sont liés au même endroit en mémoire qui contient les
 attributs de l'objet (il n'y a donc qu'un seul objet).</p>
 <p class = taille75>Problème : comment déterminer
  si le contenu de  <cg>obj1</cg> est le même que le contenu de  <cg>obj2</cg>, si ces deux objets sont différents ?</p>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>
<h3>3.18 – Comparaison d'objets</h3>
<p>La notion d’égalité est différente de la notion d’identité
</p>
<pre><code class="python" data-trim data-line-numbers style="font-size:25px;">
>>> figA = figB = Figure(3, 4)
>>> figC = Figure(3, 4)
>>>	
>>> figA == figB    # sont bien identiques (références)
True
>>>	
>>> figA == figC    # sont bien égaux (valeurs)
False               # mais euh ?!
>>>	
</pre></code>
</section>
<section>
<ul>
	<li>Ligne 7 : La comparaison de deux objets différents renvoie la valeur <cdb>False</cdb> 
	car cela compare les deux adresses mémoire qui sont différentes.</li>
	<li><cg>figA</cg> et <cg>figC</cg> on les deux été construit à l'aide du constructeur
	 <cg>Figure()</cg> et donc pour chacun un objet a été créé en mémoire. Alors que <cg>figB</cg> 
	 est juste une copie de l'adresse de <cg>figA</cg>. </li>
</ul>	
</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
<section>
<section>

</section>
<section>

</section>
</section>
<!-- ------------------------------------------------------------------------------------ -->
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
			Reveal.configure({ slideNumber: true });  
			Reveal.configure({ slideNumber: 'h/v' });
		</script>
	</body>
</html>
